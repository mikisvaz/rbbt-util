#!/usr/bin/env ruby

require 'rbbt-util'
require 'rbbt/util/simpleopt'
require 'rbbt/workflow'

$0 = "rbbt #{$previous_commands*""} #{ File.basename(__FILE__) }" if $previous_commands

options = SOPT.setup <<EOF

Report the status of the system

$ rbbt system status 

-h--help Print this help
EOF
rbbt_usage and exit 0 if options[:help]

def find_locks(dir)
  dir.glob("**/*.lock")
end

def find_persists(dir)
  dir.glob("**/*.persist")
end

def pid_msg(pid)
  color = if Misc.pid_exists? pid
            :green
          else
            :red
          end
  Log.color(color, pid)
end

def status_msg(status)
  color = case status
          when :error, :aborted, :missing
            :red
          when :streaming, :started
            :yellow
          when :done
            :green
          else
            if status.index ">"
              :yellow
            else
              nil
            end
          end
  Log.color(color, status)
end

def load_jobs(dir)
  job_files = {}
  workflow_dirs = dir.glob("*").each do |wdir|
    workflow = File.basename(wdir)
    job_files[workflow] = {}
    task_dirs = wdir.glob('*')
    task_dirs.each do |tdir|
      task = File.basename(tdir)
      job_files[workflow][task] = tdir.glob('*')
    end
  end
  jobs = {}
  job_files.each do |workflow,task_jobs|
    jobs[workflow] ||= {}
    task_jobs.each do |task, files|
      jobs[workflow][task] ||= {}
      files.each do |f|
        next if f =~ /\.lock$/
        job = f.sub(/\.(info|files)/,'')

        jobs[workflow][task][job] ||= {}
        if jobs[workflow][task][job][:status].nil? 
          status = nil
          status = :done if Open.exists? job
          if status.nil? and f=~/\.info/
            info = begin
                     Step::INFO_SERIALIAZER.load(Open.read(f, :mode => 'rb'))
                   rescue
                     {}
                   end 
            status = info[:status]
            pid = info[:pid]
          end

          jobs[workflow][task][job][:pid] = pid if pid
          jobs[workflow][task][job][:status] = status if status
        end
      end
    end
  end
  jobs
end

lock_dirs    = Rbbt.share.find_all  + Rbbt.var.cache.persistence.find_all + Rbbt.tmp.tsv_open_locks.find_all + Rbbt.var.jobs.find_all 
persist_dirs = Rbbt.share.find_all  + Rbbt.var.cache.persistence.find_all 
sensiblewrite_dirs = Rbbt.tmp.sensiblewrite.find_all

locks = lock_dirs.inject([]) do |acc,e|
  acc += find_locks(e)
end

persists = persist_dirs.inject([]) do |acc,e|
  acc += find_persists(e)
end

sensiblewrites = sensiblewrite_dirs.inject([]) do |acc,e|
  acc += e.glob('*').reject{|d| d=~/\.lock$/}
end

puts Log.color(:magenta, "# System report")
puts
if locks.any?
  puts Log.color(:magenta, "Locks:")
  locks.each do |lock|
    pid, ppid, time = YAML.load(Open.read(lock)).values_at "pid", "ppid", "time"
    puts "  " << lock + Log.color(:blue, " -- time: #{Time.now - time}; ppid: #{ppid}; pid: #{pid_msg pid}")
  end
  puts
end

if persists.any?
  puts Log.color(:magenta, "Persist:")
  persists.each do |persist|
    puts "  " << persist
  end
  puts
end

if sensiblewrites.any?
  puts Log.color(:magenta, "Writing:")
  sensiblewrites.each do |sensiblewrite|
    pid, ppid, time = YAML.load(Open.read(sensiblewrite + '.lock')).values_at "pid", "ppid", "time"
    puts "  " << sensiblewrite + Log.color(:blue, " -- time: #{Time.now - time}; ppid: #{ppid}; pid: #{pid_msg pid}")
  end
  puts
end

jobs = load_jobs(Rbbt.var.jobs)

puts Log.color(:magenta, "# Workflows:")
puts
jobs.each do |workflow, tasks|
  tasks.each do |task, jobs|
    puts "* " << Log.color(:magenta, workflow) << "#" << Log.color(:yellow, task) << ": "
    done = []
    other = {}
    jobs.each do |file,h|
      status = h[:status]
      if h[:status] == :done
        done << file
      else
        other[status||"missing"] ||= []
        other[status||"missing"] << [file, h[:pid]]
      end
    end
    puts "  " << Log.color(:green, "done") << ": " << done.length.to_s
    other.each do |status, list|
      puts "  " << status_msg(status) << ": " << list.collect{|f,p| p.nil? ? f : f + " (#{pid_msg p})"} * ", "
    end
  end
end

